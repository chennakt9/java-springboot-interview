- How would you optimize large batch inserts/updates in Hibernate?
  - Enable JDBC batching (hibernate.jdbc.batch_size=50)
  - Flush and clear in chunks
      ```Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();
        
        int batchSize = 50;
        for (int i = 0; i < items.size(); i++) {
        session.save(items.get(i));
        
            if (i % batchSize == 0) {
                session.flush();
                session.clear(); // Detach objects to free memory
            }
        }
        
        tx.commit();
        session.close();
      ```
- Explain difference between entity graphs and fetch joins for optimizing queries.
  - Fetch Joins
    - we write query ourself, we get answer in single sql query using joins
  - Entity Graphs
    - You define a fetch plan declaratively
    - JPA decides the best query (usually adds JOIN FETCH behind the scenes)

- How does 2nd level caching work in Hibernate and which providers have you used?
  - redis is a l2 cache (or Ehcache)
  - 1st-level cache - Hibernate internal - persistent context

- How to handle optimistic locking failures gracefully?
  - Optimistic locking = “I assume no one else changes this row while I’m editing it…
    but I’ll double-check before saving.” Hibernate does this using a @Version field
  - Catch it and retry
    - If your operation is idempotent (like updating a counter), you can also implement a retry mechanism
  - Show a friendly message (UI / API layer)
    - The record was updated by someone else while you were editing. Please refresh and try again.
  - Event-based handling
    - in microservices, emit an event when a version conflict happens, and have a compensating mechanism
    - like saga
- How do you tune SQL queries generated by JPA for performance?
  - spring.jpa.show-sql=true
  - Kill the N+1 query problem
  - Use pagination
  - Use projections wisely
  - Leverage batch fetching and fetch size
  - Use 2nd level cache (redis)
  - Add proper indexes.
  - Avoid SELECT * from large joined tables.
  - Use database-specific hints via native queries if needed.
  - Prefer JOIN FETCH over @ManyToOne(fetch = EAGER)
