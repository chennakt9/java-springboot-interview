- How would you optimize large batch inserts/updates in Hibernate?
  - Enable JDBC batching (hibernate.jdbc.batch_size=50)
  - Flush and clear in chunks
      ```Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();
        
        int batchSize = 50;
        for (int i = 0; i < items.size(); i++) {
        session.save(items.get(i));
        
            if (i % batchSize == 0) {
                session.flush();
                session.clear(); // Detach objects to free memory
            }
        }
        
        tx.commit();
        session.close();
      ```
- Explain difference between entity graphs and fetch joins for optimizing queries.
  - Fetch Joins
    - we write query ourself, we get answer in single sql query using joins
  - Entity Graphs
    - You define a fetch plan declaratively
    - JPA decides the best query (usually adds JOIN FETCH behind the scenes)

- How does 2nd level caching work in Hibernate and which providers have you used?
  - redis is a l2 cache (or Ehcache)
  - 1st-level cache - Hibernate internal - persistent context

- How to handle optimistic locking failures gracefully?
  - Optimistic locking = “I assume no one else changes this row while I’m editing it…
    but I’ll double-check before saving.” Hibernate does this using a @Version field
  - Catch it and retry
    - If your operation is idempotent (like updating a counter), you can also implement a retry mechanism
  - Show a friendly message (UI / API layer)
    - The record was updated by someone else while you were editing. Please refresh and try again.
  - Event-based handling
    - in microservices, emit an event when a version conflict happens, and have a compensating mechanism
    - like saga
- How do you tune SQL queries generated by JPA for performance?
  - spring.jpa.show-sql=true
  - Kill the N+1 query problem
  - Use pagination
  - Use projections wisely
  - Leverage batch fetching and fetch size
  - Use 2nd level cache (redis)
  - Add proper indexes.
  - Avoid SELECT * from large joined tables.
  - Use database-specific hints via native queries if needed.
  - Prefer JOIN FETCH over @ManyToOne(fetch = EAGER)

- Difference between Lazy and Eager loading
  - Lazy : Related entities are fetched only when you access them.
  - Eager
    - Related entities are fetched immediately along with the main entity.
    - If we use join fetch, we can solve N + 1 problem
  
- What are N+1 query problems? How to solve them?
  - Use JOIN FETCH
  - Use Entity Graph

- How does Hibernate manage transactions?
  - @Transactional
    - Open a transaction at method start.
    - Commit it if no exceptions occur.
    - Rollback automatically on exceptions.
  - flow
    - session.beginTransaction()
    - All operations (save, update, delete) are queued in Hibernate’s first-level cache (session).
    - session.flush() / tx.commit() → flushes the session to the database and commits the transaction.
    - If an exception occurs → tx.rollback() ensures atomicity.

- Entity lifecycle states (Transient, Persistent, Detached, Removed)
  - Transient
    - A new object that exists only in memory, not associated with any Hibernate Session
    - User user = new User(); // transient
  - Persistent
    - An object that is associated with a Hibernate Session and will be synchronized with the database on commit.
  - Detached
    - A persistent object whose Session has been closed, or it has been evicted from the session.
