- How would you optimize large batch inserts/updates in Hibernate?
  - Enable JDBC batching (hibernate.jdbc.batch_size=50)
  - Flush and clear in chunks
      ```Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();
        
        int batchSize = 50;
        for (int i = 0; i < items.size(); i++) {
        session.save(items.get(i));
        
            if (i % batchSize == 0) {
                session.flush();
                session.clear(); // Detach objects to free memory
            }
        }
        
        tx.commit();
        session.close();
      ```
- Explain difference between entity graphs and fetch joins for optimizing queries.
  - Fetch Joins
    - we write query ourself, we get answer in single sql query using joins
  - Entity Graphs
    - You define a fetch plan declaratively
    - JPA decides the best query (usually adds JOIN FETCH behind the scenes)

- How does 2nd level caching work in Hibernate and which providers have you used?
  - redis is a l2 cache (or Ehcache)
  - 1st-level cache - Hibernate internal - persistent context

- How to handle optimistic locking failures gracefully?
  - Optimistic locking = “I assume no one else changes this row while I’m editing it…
    but I’ll double-check before saving.” Hibernate does this using a @Version field
  - Catch it and retry
    - If your operation is idempotent (like updating a counter), you can also implement a retry mechanism
  - Show a friendly message (UI / API layer)
    - The record was updated by someone else while you were editing. Please refresh and try again.
  - Event-based handling
    - in microservices, emit an event when a version conflict happens, and have a compensating mechanism
    - like saga
- How do you tune SQL queries generated by JPA for performance?
  - spring.jpa.show-sql=true
  - Kill the N+1 query problem
  - Use pagination
  - Use projections wisely
  - Leverage batch fetching and fetch size
  - Use 2nd level cache (redis)
  - Add proper indexes.
  - Avoid SELECT * from large joined tables.
  - Use database-specific hints via native queries if needed.
  - Prefer JOIN FETCH over @ManyToOne(fetch = EAGER)

- Difference between Lazy and Eager loading
  - Lazy : Related entities are fetched only when you access them.
  - Eager
    - Related entities are fetched immediately along with the main entity.
    - If we use join fetch, we can solve N + 1 problem
  
- What are N+1 query problems? How to solve them?
  - Use JOIN FETCH
  - Use Entity Graph

- How does Hibernate manage transactions?
  - @Transactional
    - Open a transaction at method start.
    - Commit it if no exceptions occur.
    - Rollback automatically on exceptions.
  - flow
    - session.beginTransaction()
    - All operations (save, update, delete) are queued in Hibernate’s first-level cache (session).
    - session.flush() / tx.commit() → flushes the session to the database and commits the transaction.
    - If an exception occurs → tx.rollback() ensures atomicity.

- Entity lifecycle states (Transient, Persistent, Detached, Removed)
  - Transient
    - A new object that exists only in memory, not associated with any Hibernate Session
    - User user = new User(); // transient
  - Persistent
    - An object that is associated with a Hibernate Session and will be synchronized with the database on commit.
  - Detached
    - A persistent object whose Session has been closed, or it has been evicted from the session.

  - Difference between save(), saveOrUpdate(), and persist() in Hibernate.
    - save() → Inserts a new record and returns the generated ID.
    - saveOrUpdate() → Inserts if new, updates if existing.
    - persist() → Makes entity managed (inserted only on flush), no ID returned, JPA-standard.

- Explain lazy loading and how to avoid LazyInitializationException.
  - Lazy loading: Hibernate fetches related data only when accessed, not when the parent entity is loaded.
  - LazyInitializationException: Happens if you access lazy data after the session is closed.
  - How to avoid:
    - Fetch data within the session using fetch join or Hibernate.initialize().
    - Keep the session open until data access (Open Session in View).
    - Use EAGER fetch cautiously for small associations.

- How does @OneToMany and @ManyToOne mapping work?
  - @OneToMany: One entity is linked to many others; inverse side, default LAZY, e.g., one User has many Orders.
  - @ManyToOne: Many entities link to one; owning side with foreign key, default EAGER, e.g., many Orders belong to one User.

- How do you use pagination and sorting in Spring Data JPA?
  - PageRequest.of(page, size, sort) → creates a pageable object.
    - page → 0-based page index.
    - size → number of records per page.
    - sort → field(s) to sort by (asc/desc).

- Explain optimistic vs pessimistic locking in JPA.
  - Optimistic Locking
    - Concept: Assumes conflicts are rare; multiple transactions can read the same entity.
    - Uses a version field (@Version) in the entity.
    - When updating, JPA checks the version — if it changed since read, throws OptimisticLockException.
    - Use case: High-read, low-write scenarios.
  - Pessimistic Locking
    - Concept: Assumes conflicts are likely; locks the entity when reading it.
    - How it works:
      - Uses database locks to prevent other transactions from updating the entity until the lock is released.
      - Can be PESSIMISTIC_READ or PESSIMISTIC_WRITE.
    - Use case: High-write scenarios where conflicts must be prevented.
